#import rayui;
#import time;

Scene :: enum {
  BETTING_MENU,
  RACE_SCENE,
  ROUND_OVER_MENU,
}

selected_horse: u8;

scene: Scene = Scene::BETTING_MENU;

Stint :: struct {
  begin:    float;
  duration: float;
}

Horse :: struct {
  progress:        float;
  current_speed:   float;
  target_speed:    float;
  stint:           Stint;
  odds:            float;
  visual_odds:     s64;
}

winning_horse_index: s32;
bet: s32;
user_balance: s32 = 1000;
debt : s32 = 0;

HORSE_SIZE :: 40;
NUM_LANES  :: 4;

horses: Horse[NUM_LANES];

colors: Color[NUM_LANES] = {
  RED,
  GREEN,
  YELLOW,
  BLUE
};

last_winnings: s32;

refresh_odds :: fn() {
  high_roller_idx := GetRandomValue(0, NUM_LANES - 1);
  high_roller_odds := GetRandomValue(15, 30);
  horses[high_roller_idx].odds = high_roller_odds as float;
  horses[high_roller_idx].visual_odds = high_roller_odds;

  for i in 0..NUM_LANES {
    if i != high_roller_idx {
      numerator := 1;
      denominator := GetRandomValue(2, 20);
      horses[i].odds = (denominator as float) / (numerator as float);
      horses[i].visual_odds = denominator;
    }
  }
}

draw :: fn() {
  finish_line_x := ((GetScreenWidth() as float) * 0.9) as s32;
  DrawRectangle(finish_line_x, 0, 45, GetScreenHeight(), PURPLE);
  LANE_HEIGHT := GetScreenHeight() / NUM_LANES;
  PADDING := LANE_HEIGHT / 10;
  for i in 0..NUM_LANES {
    horse := horses[i];
    x : s32 = GetScreenWidth() * horse.progress;
    y : s32 = ((i % NUM_LANES) * LANE_HEIGHT + PADDING + HORSE_SIZE) as s32;
    DrawRectangle(x, y, HORSE_SIZE, HORSE_SIZE, colors[i]);
  }
}

update_stint :: fn(horse: Horse*) {
  // if the stint is over, or it never began, restart it.
  time := GetTime();   
  if horse.stint.duration == 0 || time - horse.stint.begin >= horse.stint.duration {
    horse.stint.begin = time;
    horse.stint.duration = GetRandomValue(1, 2);
    horse.target_speed = GetRandomValue(1, 2) as float / 1000.0;
  }
}

update :: fn() {
  for i in 0..NUM_LANES {
    horse := &horses[i];
    update_stint(horse);    
    horse.progress = fmod(horse.progress + horse.current_speed, 1.0);
    horse.current_speed = lerp(horse.current_speed, horse.target_speed, 0.01);
    if (horse.progress > 0.9) {
      winning_horse_index = i as u8;
      if selected_horse == i {
        winnings := bet * horse.odds;
        if debt < 0 {
          amount_to_pay := min![s32](winnings, -debt);
          debt += amount_to_pay;
          winnings -= amount_to_pay;
        }
        user_balance += winnings;
        last_winnings = winnings;
      }
      memset(horses, 0, sizeof(Horse) * NUM_LANES);
      refresh_odds();
      scene = Scene::ROUND_OVER_MENU;
      break;
    }
  }
}

draw_betting_menu :: fn() {
  BUTTON_WIDTH  := GetScreenWidth() / 10;
  BUTTON_HEIGHT := 80;

  style := Style {
    foreground: WHITE,
    background: GRAY,
    font_size:  16,
    use_jiggly_text: false,
  };

  rect := Rectangle {
    x: (GetScreenWidth() / 2) - BUTTON_WIDTH,
    y: (GetScreenHeight() / 2),
    width: BUTTON_WIDTH,
    height: BUTTON_HEIGHT
  };
    
  if button("Increase Bet", rect, style) {
    if bet == 0 then bet = 10;
    bet *= 1.2;
    if bet > user_balance then bet = user_balance;
  }
  
  rect.x += (BUTTON_WIDTH as float) * 1.5;
  if button("Decrease Bet", rect, style) {
    bet /= 1.2;
    if bet <= 0 then bet = 0;
  }

  prev_x := rect.x;

  rect.x += (BUTTON_WIDTH as float) * 1.5;

  if button("Max Bet", rect, style) {
    bet = user_balance;
  }

  rect.x = prev_x;

  text := $"Current Bet: {bet}";
  DrawText(text, rect.x as s32 - (BUTTON_WIDTH), (rect.y as s32) - BUTTON_HEIGHT * 3, 32, WHITE);
  free(text);

  rect.x -= BUTTON_WIDTH / 1.25;
  rect.y += BUTTON_HEIGHT * 1.5;
  
  if button("Start Race", rect, style) {
    if user_balance > 0 && bet > 0 {
      scene = Scene::RACE_SCENE;
      //memset(horses, 0, sizeof(Horse) * NUM_LANES);
      user_balance -= bet;
    } else {
      style.foreground = RED;
    }
  }

  text = $"Current Balance: ${user_balance}";
  DrawText(text, rect.x as s32, (rect.y - BUTTON_HEIGHT * 2) as s32, 18, GREEN);
  free(text);
  text = $"Debt : {debt}";
  DrawText(text, rect.x as s32 + MeasureText(text, 18), (rect.y - BUTTON_HEIGHT * 2.5) as s32, 18, RED);
  free(text);

  for i in 0..NUM_LANES {
    rect := Rectangle {
      x: (i * BUTTON_WIDTH / 2) as float,
      y: GetScreenHeight() / 1.25,
      width:  BUTTON_WIDTH / 2,
      height: BUTTON_HEIGHT / 2,
    };
    
    style.foreground = colors[i];
    style.background = GRAY.with_alpha(25);
    text := $"{1}/{horses[i].visual_odds}";
    defer free(text);
    if button(text, rect, style) then selected_horse = i;
  }

  loan_rect_1 := Rectangle {
      x: GetScreenWidth() - (2 * BUTTON_WIDTH),
      y: GetScreenHeight() - (3 * BUTTON_HEIGHT),
      width: BUTTON_WIDTH,
      height: BUTTON_HEIGHT
  };

  loan_rect_2 := Rectangle {
      x: GetScreenWidth() - (2 * BUTTON_WIDTH),
      y: GetScreenHeight() - (2 * BUTTON_HEIGHT),
      width: BUTTON_WIDTH,
      height: BUTTON_HEIGHT
  };

  loan_rect_3 := Rectangle {
      x: GetScreenWidth() - (2 * BUTTON_WIDTH),
      y: GetScreenHeight() - BUTTON_HEIGHT,
      width: BUTTON_WIDTH,
      height: BUTTON_HEIGHT
  };

  style.foreground = ORANGE;

  DrawText("Take loan, 15% interest.", loan_rect_1.x as s32, (loan_rect_1.y as s32) - 24, 16, ORANGE);  

  if button("$1,000", loan_rect_1, style) {
    user_balance += 1000;
    debt -= 1000 * 1.5;
  }

  if button("$5,000", loan_rect_2, style) {
    user_balance += 5000;
    debt -= 5000 * 1.5;
  }

  if button("$10,000", loan_rect_3, style) {
    user_balance += 10000;
    debt -= 10_000 * 1.5;
  }
}

draw_your_horse_indicator :: fn() {
  text := $"{selected_horse}, bet: ${bet}\nprojected win: ${((bet as float) * horses[selected_horse].odds) as s32}";
  width := MeasureText(text, 18);
  DrawRectangle(0, 0, width * 1.2, HORSE_SIZE, colors[selected_horse]);
  defer free(text);
  DrawText(text, 4, 0, 18, BLACK);
}

draw_round_over_menu :: fn() {
  
  #static style := Style {
    foreground: WHITE,
    background: CLEAR,
    font_size: 32
  };

  color_name := switch winning_horse_index {
    0 => "red",
    1 => "green",
    2 => "yellow",
    3 => "blue",
  };
  
  text := $"Horse #{winning_horse_index+1} ({color_name})  wins!!\n";
  width := measure_jiggly_text(text, style) / 2;


  text_rect := Rectangle {
    x: (GetScreenWidth() / 2 - width),
    y: (GetScreenHeight() / 2),
    width: 0,
    height: 0
  };
  
  jiggly_text(text, text_rect, style);
  free(text);


  if selected_horse == winning_horse_index {
    text = $"You win ${last_winnings}";
    DrawText(text, (text_rect.x as s32), (text_rect.y as s32) - style.font_size * 2, 32, GREEN);
    free(text);
  } else {
    text = $"You lost ${bet}";
    DrawText(text, (text_rect.x as s32), (text_rect.y as s32) - style.font_size * 2, 32, RED);
    free(text);
  }
  
  

  BUTTON_WIDTH  := GetScreenWidth() / 10;
  BUTTON_HEIGHT := 80;

  #static button_style := Style {
    foreground: WHITE,
    background: GRAY,
    font_size:  24,
    use_jiggly_text: false,
  };

  width = MeasureText("Back to betting menu", 24);

  button_rect := Rectangle {
    x: (GetScreenWidth() / 2) - (width / 2),
    y: (GetScreenHeight() / 4),
    width: BUTTON_WIDTH,
    height: BUTTON_HEIGHT
  };

  if button("Back to betting menu", button_rect, button_style) {
    bet = 0;
    scene = Scene::BETTING_MENU;
  }    
}

main :: fn() {
  
  SetTraceLogLevel(TraceLogLevel::LOG_NONE);
  InitWindow(1920, 600, "Debt Simulator");
  SetTargetFPS(60);

  refresh_odds();
  
  while !WindowShouldClose() {
    BeginDrawing();
      ClearBackground(BLACK);
      switch scene {
        Scene::BETTING_MENU: {
          draw_betting_menu();
        }
        Scene::RACE_SCENE: {
          draw();
          update();
        }
        Scene::ROUND_OVER_MENU: {
          draw_round_over_menu();
        }
      }
    draw_your_horse_indicator();
    EndDrawing();
  }
}
